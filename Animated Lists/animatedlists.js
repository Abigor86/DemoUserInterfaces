// ------------------------------------------------------------------
// AnimatedLists.js
//
// Demonstrates CommandFusion iViewer list manipulation in JavaScript
//
// Author: Florent Pillet, CommandFusion
// ------------------------------------------------------------------

CF.userMain = function() {
	// Our main script function that iViewer calls as soon as the GUI
	// is loaded, and iViewer is ready to run Javascript
	generateListData();
};

function generateListData() {
	// Generate list data for both the horizontal list (l1)
	// and the vertical list (l10). We use http://www.lorempixum.com
	// to obtain random images for each image in the list.
	//
	// We need to generate a unique URL for each image, otherwise we
	// will send out multiple requests to LoremPixum, but every time
	// we receive an image, all the image elements in our GUI will
	// update with this image since they would all be looking at the
	// same URL to gather their image.
	//
	// To perform this, we add a unique parameter to each request
	// that will be ignored by LoremPixum, but will ensure that each
	// image is request a unique URL
	var items = [];
	for (var i=0; i < 30; i++) {
		items.push({
			// add an unused parameter so that each request is unique
			s1:"http://www.lorempixum.com/120/120/?"+i,
			s2:(i+1).toString(),
			s3:""
		});
	}
	CF.listAdd("l1", items);
	
	items = [];
	for (var i=0; i < 30; i++) {
		items.push({
			// add an unused parameter so that each request is unique
			s1:"http://www.lorempixum.com/120/120/?100"+i,
			s2:(i+1).toString()
		});
	}
	CF.listAdd("l10", items);
}

function onListDidScroll(info) {
	//
	// A list has just scrolled. This function is called by the
	// HListDidScroll and VListDidScroll commands defined in the
	// loopback system (see GUI in GUI Designer)
	//
	// We want to update the text joins that show information about the current scroll position,
	// number of items and number of visible items.
	//
	// Since we are handling both lists l1 and l10 in this code,
	// we want to route the text updates to s2/s3/s4 (for l1) or s12/s13/s14 (for l10)
	//
	var join = (info.list=="l1") ? "s" : "s1";
	var updates = [
		{ "join": join+"2", value: info.count },
		{ "join": join+"3", value: info.top },
		{ "join": join+"4", value: info.visible }
	];
	CF.setJoins(updates);
}

function onDoScrollList(listJoin, position) {
	//
	// Programmatically scroll the list to the given position
	//
	// We receive a scrollData object generated by the ScrollList command (from Loopback)
	// The object carries the list join, and the position we need to set. Since the position
	// is generated from the slider position, it's 0-100 so we need to convert it to an
	// actual item index.
	// To do this, we first obtain the list info which gives us the number of items in the
	// list, then compute the actual item index we want to scroll to.
	//
	CF.listInfo(listJoin, function(j, count, first, numVisible) {
		var nonvisible = (count - numVisible);
		var index = Math.min(Math.max(0, Math.round((nonvisible / 100) * position)), count-1);
		CF.listScroll(listJoin, index, CF.TopPosition, true);
	});
}

function doListAnimation1() {
	//
	// Sample animation of list items using object property changes
	//
	// Perform a wave-like animation: images will move downwards and become slightly
	// transparent, then will come back to their original transparency and position.
	// We use a short delay to start each animation to produce the wave effect.
	//
	// We animate only list items that are currently visible, which we get using
	// the CF.listInfo() call.
	//
	CF.listInfo("l1", function(list, count, first, numVisible) {
		for (var i=first, delay=0.0; i < first + numVisible; i++) {
			var j="l1:"+i+":s1";
			CF.setProperties({join: j, y: 80, opacity: 0.33}, delay, 0.33, CF.AnimationCurveLinear, function(joinString) {
				CF.setProperties({join: joinString, y: 0, opacity: 1.0}, 0.0, 0.33, CF.AnimationCurveLinear);
			}, j);
			delay += 0.05;
		}
	});
}

function doListAnimation2() {
	//
	// Sample animation of list items using object property changes
	//
	// Scale down each image in turn, starting from the left of the top list,
	// then scale them back to original size starting from the right.
	//
	// We animate only list items that are currently visible, which we get using
	// the CF.listInfo() call.
	//
	CF.listInfo("l1", function(list, count, first, numVisible) {
		for (var i=first, delay=0.0; i < first + numVisible; i++) {
			if (i == (first + numVisible - 1)) {
				CF.setProperties({join: "l1:"+i+":s1", scale: 0.5}, delay, 0.33, CF.AnimationCurveLinear, function() {
					for (var j=first+numVisible-1, delay2=0.0; j>=first; j--) {
						CF.setProperties({join: "l1:"+j+":s1", scale: 1.0}, delay2, 0.33, CF.AnimationCurveLinear);
						delay2 += 0.05;
					}
				});
			} else {
				CF.setProperties({join: "l1:"+i+":s1", scale: 0.5}, delay, 0.33, CF.AnimationCurveLinear);
			}
			delay += 0.05;
		}
	});
}

function doListAnimation3() {
	//
	// Sample animation of list items using object property changes
	//
	// Perfom a flowing shade like effect by tuning the opacity of each item
	// in turn, with a slight start delay for each item to produce an effect
	// going from left to right.
	//
	// We animate only list items that are currently visible, which we get using
	// the CF.listInfo() call.
	//
	CF.listInfo("l1", function(list, count, first, numVisible) {
		for (var i=first, delay=0.0; i < first + numVisible; i++) {
			var j="l1:"+i+":s1";
			CF.setProperties({join: j, opacity: 0.25}, delay, 0.33, CF.AnimationCurveLinear, function(joinString) {
				CF.setProperties({join: joinString, y: 0, opacity: 1.0}, 0.0, 0.33, CF.AnimationCurveLinear);
			}, j);
			delay += 0.05;
		}
	});
}
